<!DOCTYPE html><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge, chrome=1"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="description" content="Swift中的Extension"><meta name="author" content="AidaHe"><meta name="keywords" content="Swift,Extension"><meta name="copyright" content="copyright.liscense_type"><title>Swift中的Extension</title><!-- HTML5 shim and Respond.js for IE8 support of HTML5 elements and media queries -->
<!--[if lt IE 9]><script src="https://cdn.bootcss.com/html5shiv/3.7.3/html5shiv.min.js"></script><script src="https://cdn.bootcss.com/respond/1.4.2/respond.min.js"></script><![endif]--><link rel="icon" href="/compass/imgs/favicon.ico"><link rel="stylesheet" href="/compass/stylesheets/font-awesome.min.css"><script>var algoliaConfig = {"on":false}</script><link rel="stylesheet" href="/compass/stylesheets/screen.css"><meta name="generator" content="Hexo 4.2.0"></head><body><div id="body-inner-wrapper"><header id="page-header"><nav id="nav"><div id="site-name">AidaHe‘s blog</div><i class="fa fa-bars fa-2x" id="nav-icon" aria-hidden="true"></i><div id="nav-expanded"><a class="nav-word-item" href="/">主页</a><a class="nav-word-item" href="/archives">归档</a><a class="nav-word-item" href="/tags">标签</a><a class="nav-word-item" href="/categories">分类</a><a class="nav-word-item" href="/about">nav.about</a></div><div id="nav-list"><ul><li><a class="nav-list-item" href="/">主页</a></li><li><a class="nav-list-item" href="/archives">归档</a></li><li><a class="nav-list-item" href="/tags">标签</a></li><li><a class="nav-list-item" href="/categories">分类</a></li><li><a class="nav-list-item" href="/about">nav.about</a></li></ul></div></nav><div id="banner-wrapper"><div id="banner-pagetype-dependent-info"><h1 id="post-title">Swift中的Extension</h1><span id="post-description"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-05-09</span><span id="word-count">全文共 2136 字</span><span id="time-count">需阅读时间约 8 分钟</span></div></div><a title="回到顶部"><i class="fa fa-arrow-up" id="to-Top" aria-hidden="true"></i></a><a title="点击关闭目录"><i class="fa fa-toggle-on" id="toggle-on-Toc" aria-hidden="true"></i></a><a title="点击展开目录"><i class="fa fa-toggle-off" id="toggle-off-Toc" aria-hidden="true"></i></a></header><aside id="toc-column"><div id="toc-column-inner-wrapper"><div id="post-toc"><ol class="toc"><li class="toc-item toc-level-4"><a class="toc-link" href="#一、添加计算型属性、计算型静态属性、“存储属性”"><span class="toc-text">一、添加计算型属性、计算型静态属性、“存储属性”</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#在协议中添加optional属性"><span class="toc-text">在协议中添加optional属性</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#二、定义实例方法和类型方法"><span class="toc-text">二、定义实例方法和类型方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#三、提供新的构造器"><span class="toc-text">三、提供新的构造器</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1，给结构体添加新的构造器"><span class="toc-text">1，给结构体添加新的构造器</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2，给类添加新的构造器"><span class="toc-text">2，给类添加新的构造器</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#四、定义下标"><span class="toc-text">四、定义下标</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#五、定义嵌套类型"><span class="toc-text">五、定义嵌套类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#六、使一个已有类型符合某个协议"><span class="toc-text">六、使一个已有类型符合某个协议</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#七、拓展协议添加where从句"><span class="toc-text">七、拓展协议添加where从句</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#八、通过拓展协议实现命名空间"><span class="toc-text">八、通过拓展协议实现命名空间</span></a></li></ol></div></div></aside><main id="main-content-column"><div id="main-content-wrapper"><div id="post-full-content"><p>Swift中可以对类，结构体，协议，枚举进行拓展添加新的功能<br>考虑到本篇博文中的篇幅，关于枚举的拓展将在下一篇介绍<code>ps:</code>基于Swift 5<br>Swift 中的扩展可以：</p>
<ul>
<li>一、添加计算型属性和计算型静态属性</li>
<li>二、定义实例方法和类型方法</li>
<li>三、提供新的构造器</li>
<li>四、定义下标</li>
<li>五、定义和使用新的嵌套类型</li>
<li>六、使一个已有类型符合某个协议<a id="more"></a>
<h4 id="一、添加计算型属性、计算型静态属性、“存储属性”"><a href="#一、添加计算型属性、计算型静态属性、“存储属性”" class="headerlink" title="一、添加计算型属性、计算型静态属性、“存储属性”"></a>一、添加计算型属性、计算型静态属性、“存储属性”</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">class Animal:NSObject &#123;</span><br><span class="line">    var age:Int?</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private var animalName:String &#x3D; &quot;&quot;</span><br><span class="line">extension Animal &#123;</span><br><span class="line">    &#x2F;&#x2F;1添加静态计算属性</span><br><span class="line">    static var c:Int&#123;</span><br><span class="line">        get &#123;</span><br><span class="line">            print(&quot;get c&quot;)</span><br><span class="line">            return 3</span><br><span class="line">        &#125;</span><br><span class="line">        set&#123;</span><br><span class="line">            print(&quot;set c:\(newValue)&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;2添加计算属性</span><br><span class="line">    var isAdult:Bool&#123;</span><br><span class="line">        get&#123;</span><br><span class="line">            return self.age ?? 0 &gt; 2</span><br><span class="line">        &#125;</span><br><span class="line">        set&#123;</span><br><span class="line">            if newValue &#123;</span><br><span class="line">                self.age &#x3D; 2</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                self.age &#x3D; 0</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;3使用AssociatedObject添加存储属性</span><br><span class="line">    var name:String &#123;</span><br><span class="line">        get&#123;</span><br><span class="line">            return objc_getAssociatedObject(self, &amp;animalName) as! String</span><br><span class="line">        &#125;</span><br><span class="line">        set&#123;</span><br><span class="line">            objc_setAssociatedObject(self, &amp;animalName, newValue, .OBJC_ASSOCIATION_ASSIGN)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
调用示例<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">let animal &#x3D; Animal()</span><br><span class="line">animal.age &#x3D; 3</span><br><span class="line">print(&quot;\(animal.age)&quot;)&#x2F;&#x2F;Optional(3)</span><br><span class="line">animal.name &#x3D; &quot;AA&quot;</span><br><span class="line">animal.isAdult &#x3D; true</span><br><span class="line">print(&quot;-----&quot;)</span><br><span class="line">print(&quot;\(animal.age)&quot;)&#x2F;&#x2F;Optional(2)</span><br><span class="line">print(&quot;\(animal.name)&quot;)&#x2F;&#x2F;AA</span><br><span class="line">Animal.c &#x3D; 6</span><br><span class="line">print(Animal.c)</span><br></pre></td></tr></table></figure>
<img src="https://upload-images.jianshu.io/upload_images/6695792-ce68ac37a0fe7081.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="调用结果"><br>1，这里需要解释一下官方文档中虽然介绍<code>extension</code>不能添加存储属性，但是依旧可以利用<code>AssociatedObject</code>来达到添加存储属性的效果<br>2，在类和结构体中添加计算属性，“存储属性”可以按照以上方式，但是在<code>protocol</code>中又会是何种情况呢？我们知道<code>protocol</code>中可以定义属性和方法，而遵循该<code>protocol</code>的类或结构体就必须实现其中的方法，添加其中的属性（Optional除外）。如果在定义<code>protocol</code>时并没有申明子类必须添加某个属性，而你通过拓展添加了一个存储属性，那你之前遵循过此协议的子类岂不是都不能编译通过了。因此在拓展协议时只能添加<code>Optional</code>属性。<h5 id="在协议中添加optional属性"><a href="#在协议中添加optional属性" class="headerlink" title="在协议中添加optional属性"></a>在协议中添加<code>optional</code>属性</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">protocol P&#123;</span><br><span class="line">    var name:String&#123; get set&#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">extension P&#123;</span><br><span class="line">    &#x2F;&#x2F;添加静态计算属性</span><br><span class="line">    static var c:Int&#123;</span><br><span class="line">        get &#123;</span><br><span class="line">            print(&quot;get c&quot;)</span><br><span class="line">            return 3</span><br><span class="line">        &#125;</span><br><span class="line">        set&#123;</span><br><span class="line">            print(&quot;set c:\(newValue)&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;添加计算属性</span><br><span class="line">    var temp:Bool&#123;</span><br><span class="line">        get&#123;</span><br><span class="line">            return true</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        set&#123;</span><br><span class="line">            print(&quot;set temp:\(newValue)&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;使用AssociatedObject添加存储属性</span><br><span class="line">    var words:String? &#123;</span><br><span class="line">        get&#123;</span><br><span class="line">            return objc_getAssociatedObject(self, &amp;animalName) as? String</span><br><span class="line">        &#125;</span><br><span class="line">        set&#123;</span><br><span class="line">            objc_setAssociatedObject(self, &amp;animalName, newValue, .OBJC_ASSOCIATION_ASSIGN)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class B : P&#123;</span><br><span class="line">    var name: String &#x3D; &quot;&quot;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<img src="https://upload-images.jianshu.io/upload_images/6695792-5469438a0298656d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="调用结果"></li>
</ul>
<h4 id="二、定义实例方法和类型方法"><a href="#二、定义实例方法和类型方法" class="headerlink" title="二、定义实例方法和类型方法"></a>二、定义实例方法和类型方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">extension String &#123;</span><br><span class="line">    func fetchDate(_ format :String &#x3D; &quot;YYYY-MM-dd HH:mm:ss&quot;) -&gt;Date?&#123;</span><br><span class="line">        let  dateFormater &#x3D; DateFormatter.init()</span><br><span class="line">        dateFormater.dateFormat &#x3D; format</span><br><span class="line">        </span><br><span class="line">        let date &#x3D; dateFormater.date(from: self)</span><br><span class="line">        return date</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>1，在结构体和类中添加拓展方法应该是日常开发中最为常见的<br>2，在拓展类时添加实例方法既可以用<code>class</code>修饰也可以使用<code>static</code>修饰，而在结构体和协议中只能使用<code>static</code>修饰，因为<code>Class methods are only allowed within classes</code></p>
<h4 id="三、提供新的构造器"><a href="#三、提供新的构造器" class="headerlink" title="三、提供新的构造器"></a>三、提供新的构造器</h4><h5 id="1，给结构体添加新的构造器"><a href="#1，给结构体添加新的构造器" class="headerlink" title="1，给结构体添加新的构造器"></a>1，给结构体添加新的构造器</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">struct H&#123;</span><br><span class="line">    var num1:Int?</span><br><span class="line">    var num2:Int?</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">extension H&#123;</span><br><span class="line">    init(num1:Int,num2:Int) &#123;</span><br><span class="line">        self.num1 &#x3D; num1</span><br><span class="line">        self.num2 &#x3D; num2</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    init(num1:Int)&#123;</span><br><span class="line">        self.num1 &#x3D; num1</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">let h &#x3D; H(num1: 2, num2: 3)</span><br><span class="line">print(h.num1)&#x2F;&#x2F;Optional(2)</span><br><span class="line">print(h.num2)&#x2F;&#x2F;Optional(3)</span><br></pre></td></tr></table></figure>
<p><img src="https://upload-images.jianshu.io/upload_images/6695792-20ba07afe643a20b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="结构体构造函数"><br>从上图的代码提示中可以看到<code>struct</code> <code>H</code>在初始化时有系统默认生成的一个无参构造函数和一个带有所有属性的构造函数，以及我们在<code>extension</code>中添加的两个构造函数</p>
<h5 id="2，给类添加新的构造器"><a href="#2，给类添加新的构造器" class="headerlink" title="2，给类添加新的构造器"></a>2，给类添加新的构造器</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">extension UIColor&#123;</span><br><span class="line">    &#x2F;&#x2F;&#x2F; hexColor</span><br><span class="line">    convenience init(hex: String , alpha: CGFloat &#x3D; 1) &#123;</span><br><span class="line">            let scanner &#x3D; Scanner(string: hex)</span><br><span class="line">            scanner.scanLocation &#x3D; 0</span><br><span class="line">            </span><br><span class="line">            var rgbValue: UInt64 &#x3D; 0</span><br><span class="line">            </span><br><span class="line">            scanner.scanHexInt64(&amp;rgbValue)</span><br><span class="line">            </span><br><span class="line">            let r &#x3D; (rgbValue &amp; 0xff0000) &gt;&gt; 16</span><br><span class="line">            let g &#x3D; (rgbValue &amp; 0xff00) &gt;&gt; 8</span><br><span class="line">            let b &#x3D; rgbValue &amp; 0xff</span><br><span class="line">            </span><br><span class="line">            self.init(</span><br><span class="line">                red: CGFloat(r) &#x2F; 0xff,</span><br><span class="line">                green: CGFloat(g) &#x2F; 0xff,</span><br><span class="line">                blue: CGFloat(b) &#x2F; 0xff, alpha: alpha</span><br><span class="line">            )</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>与<code>struct</code>不同的是在拓展类时只能添加便利构造器</p>
<h4 id="四、定义下标"><a href="#四、定义下标" class="headerlink" title="四、定义下标"></a>四、定义下标</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">extension String</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F;&#x2F; 返回索引为index的字符，未找到返回空</span><br><span class="line">    subscript(index: Int) -&gt; String &#123;</span><br><span class="line">        let range &#x3D; 0...self.count - 1</span><br><span class="line">        if range.contains(index)&#123;</span><br><span class="line">            let s &#x3D; self.index(startIndex, offsetBy: index)</span><br><span class="line">            let e &#x3D; self.index(startIndex, offsetBy: index + 1)</span><br><span class="line">            return String(self[s..&lt;e])</span><br><span class="line">        &#125;</span><br><span class="line">        return &quot;&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let str1 &#x3D; &quot;12345&quot;</span><br><span class="line">print(str1[-3])&#x2F;&#x2F; &quot;&quot;</span><br><span class="line">print(str1[3])&#x2F;&#x2F; &quot;4&quot;</span><br></pre></td></tr></table></figure>
<p>类同理</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class People&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">extension People&#123;</span><br><span class="line">    subscript(index: Int) -&gt; String &#123;</span><br><span class="line">        </span><br><span class="line">        return &quot;AA&quot;</span><br><span class="line">    &#125;</span><br><span class="line">    subscript(a:String,b:Int) -&gt; Int&#123;</span><br><span class="line">        return 3</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">let p &#x3D; People()</span><br><span class="line">print(p[2])&#x2F;&#x2F;AA</span><br><span class="line">print(p[&quot;SS&quot;,0])&#x2F;&#x2F;3</span><br></pre></td></tr></table></figure>
<p><code>ps:</code>对于类拓展下标的功能写完我真的是给<code>Swift</code>跪了,可以自定义参数，自定义返回值。上面拓展<code>String</code>的下标访问还可以理解，对于给类添加下标访问方法目前我还没有发现有什么妙用，如果有什么好案例还望不吝赐教。</p>
<h4 id="五、定义嵌套类型"><a href="#五、定义嵌套类型" class="headerlink" title="五、定义嵌套类型"></a>五、定义嵌套类型</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class People&#123;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">extension People&#123;</span><br><span class="line">    enum gender&#123;</span><br><span class="line">        case man</span><br><span class="line">        case woman</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 使用</span><br><span class="line">People.gender.man</span><br></pre></td></tr></table></figure>
<h4 id="六、使一个已有类型符合某个协议"><a href="#六、使一个已有类型符合某个协议" class="headerlink" title="六、使一个已有类型符合某个协议"></a>六、使一个已有类型符合某个协议</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">extension MAOrderListSecondViewController :UITableViewDelegate,UITableViewDataSource&#123;</span><br><span class="line">  </span><br><span class="line">    func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int &#123;</span><br><span class="line">        return dataSource.count</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    func tableView(_ tableView: UITableView, heightForRowAt indexPath: IndexPath) -&gt; CGFloat &#123;</span><br><span class="line">        return UITableView.automaticDimension</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在开发中我经常将某个类需要遵循的协议使用<code>extension</code>分割开来以提高代码的可读性</p>
<h4 id="七、拓展协议添加where从句"><a href="#七、拓展协议添加where从句" class="headerlink" title="七、拓展协议添加where从句"></a>七、拓展协议添加<code>where</code>从句</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">protocol MAViewProtocol &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">extension MAViewProtocol where Self:UIView&#123;</span><br><span class="line">    func getString() -&gt; String&#123;</span><br><span class="line">        return &quot;String&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class MATestColor:UIColor,MAViewProtocol&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class MATestView:UIView,MAViewProtocol &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let view &#x3D; MATestView()</span><br><span class="line">view.getString()</span><br><span class="line">let color &#x3D; MATestColor()</span><br><span class="line">color.getString()</span><br></pre></td></tr></table></figure>
<p>上面的代码段中<code>color.getString()</code>是无法通过编译的。首先我在<code>MAViewProtocol</code>的拓展中添加了<code>getString()</code>方法虽然<code>MATestColor</code>和<code>MATestView</code>都遵循了<code>MAViewProtocol</code>，但是我在拓展时添加了<code>where</code>从句<code>where Self:UIView</code>。意思为只有是<code>UIView</code>的子类才能使用该拓展中的方法，而<code>MATestColor</code>继承自<code>UIColor</code>因此无法调用<code>getString()</code>方法</p>
<h4 id="八、通过拓展协议实现命名空间"><a href="#八、通过拓展协议实现命名空间" class="headerlink" title="八、通过拓展协议实现命名空间"></a>八、通过拓展协议实现命名空间</h4><p>从事iOS开发的同学应该不会对<code>Kingfisher</code>中的<code>kf</code>,<code>RxSwift</code>中<code>rx</code>感到陌生</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">public struct Reactive&lt;Base&gt; &#123;</span><br><span class="line">    &#x2F;&#x2F;&#x2F; Base object to extend.</span><br><span class="line">    public let base: Base</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;&#x2F; Creates extensions with base object.</span><br><span class="line">    &#x2F;&#x2F;&#x2F;</span><br><span class="line">    &#x2F;&#x2F;&#x2F; - parameter base: Base object.</span><br><span class="line">    public init(_ base: Base) &#123;</span><br><span class="line">        self.base &#x3D; base</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;&#x2F; A type that has reactive extensions.</span><br><span class="line">public protocol ReactiveCompatible &#123;</span><br><span class="line">    &#x2F;&#x2F;&#x2F; Extended type</span><br><span class="line">    associatedtype ReactiveBase</span><br><span class="line"></span><br><span class="line">    @available(*, deprecated, renamed: &quot;ReactiveBase&quot;)</span><br><span class="line">    typealias CompatibleType &#x3D; ReactiveBase</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;&#x2F; Reactive extensions.</span><br><span class="line">    static var rx: Reactive&lt;ReactiveBase&gt;.Type &#123; get set &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;&#x2F; Reactive extensions.</span><br><span class="line">    var rx: Reactive&lt;ReactiveBase&gt; &#123; get set &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">extension ReactiveCompatible &#123;</span><br><span class="line">    &#x2F;&#x2F;&#x2F; Reactive extensions.</span><br><span class="line">    public static var rx: Reactive&lt;Self&gt;.Type &#123;</span><br><span class="line">        get &#123;</span><br><span class="line">            return Reactive&lt;Self&gt;.self</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; swiftlint:disable:next unused_setter_value</span><br><span class="line">        set &#123;</span><br><span class="line">            &#x2F;&#x2F; this enables using Reactive to &quot;mutate&quot; base type</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;&#x2F; Reactive extensions.</span><br><span class="line">    public var rx: Reactive&lt;Self&gt; &#123;</span><br><span class="line">        get &#123;</span><br><span class="line">            return Reactive(self)</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; swiftlint:disable:next unused_setter_value</span><br><span class="line">        set &#123;</span><br><span class="line">            &#x2F;&#x2F; this enables using Reactive to &quot;mutate&quot; base object</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码是从<code>RxSwift</code>框架中截取出来，目前对于我来说只是知其然不知其所以然，后续再慢慢深究吧。</p>
<blockquote>
<p>参考文献<br><a href="https://docs.swift.org/swift-book/LanguageGuide/Extensions.html#//apple_ref/doc/uid/TP40014097-CH24-ID152" target="_blank" rel="noopener">https://docs.swift.org/swift-book/LanguageGuide/Extensions.html#//apple_ref/doc/uid/TP40014097-CH24-ID152</a><br><a href="https://www.runoob.com/swift/swift-extensions.html" target="_blank" rel="noopener">https://www.runoob.com/swift/swift-extensions.html</a></p>
</blockquote>
</div><div id="post-tags-container"><i class="fa fa-tags"></i> <a class="post-tag" href="/tags/Swift/">#Swift</a>  <a class="post-tag" href="/tags/Extension/">#Extension</a></div><div id="post-categories-container"><i class="fa fa-folder-open"></i>
 <a href="/categories/Swift/">Swift</a></div></div></main><div id="pagination-wrapper"><a id="page-next" href="/2020/04/30/2020/04/moyawrap/">Moya网络请求封装 <i class="fa fa-chevron-right"></i></a></div><footer id="page-footer"><div id="footer-wrapper"><div id="blog-meta">&copy;2017-2020 By AidaHe | 主题 - <a id='theme-name' href="https://github.com/huan555/lemon-lime" target="_blank" rel="noopener"> Lemon-Lime</a> | 驱动 - <a id='theme-powered-by' href=http://hexo.io> Hexo</a></div><div id="viewed-record"><script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-eye" aria-hidden="true"></i> <span id="busuanzi_value_page_pv"></span></span></div><div id="copyright-wrapper"><i class="fa fa-cc" aria-hidden="true"></i><div id="copyright">除非有特别声明，本博客所有文章均采用 <a rel="license" href=http://creativecommons.org/licenses/by-nc-sa/4.0/>CC BY-NC-SA 4.0 协议</a>.</div></div><div id="contact-me"><div id="rss"><a href="/atom.xml" type="application/atom+xml" rel="alternate" target="_blank"><i class="fa fa-rss" aria-hidden="true"></i></a></div><span id="github"><a href="https://github.com/AidaHe" target="_blank" rel="noopener"><i class="fa fa-github" aria-hidden="true"></i></a></span></div></div></footer><script src="/compass/js/blog.js"></script></div></body>