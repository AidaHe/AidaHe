<!DOCTYPE html><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge, chrome=1"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="description" content="Swift中的Extension"><meta name="author" content="AidaHe"><meta name="keywords" content="Swift,Extension"><meta name="copyright" content="copyright.liscense_type"><title>Swift中的Extension</title><!-- HTML5 shim and Respond.js for IE8 support of HTML5 elements and media queries -->
<!--[if lt IE 9]><script src="https://cdn.bootcss.com/html5shiv/3.7.3/html5shiv.min.js"></script><script src="https://cdn.bootcss.com/respond/1.4.2/respond.min.js"></script><![endif]--><link rel="icon" href="/compass/imgs/favicon.ico"><link rel="stylesheet" href="/compass/stylesheets/font-awesome.min.css"><script>var algoliaConfig = {"on":false}</script><meta name="generator" content="Hexo 4.2.0"></head><link rel="stylesheet" href="/compass/stylesheets/screen.css"><!--link(rel='stylesheet' href='/compass/stylesheets/prism.css')--><body><div id="body-inner-wrapper"><header id="page-header"><nav id="nav"><div id="site-name">AidaHe‘s blog</div><i class="fa fa-bars fa-2x" id="nav-icon" aria-hidden="true"></i><div id="nav-expanded"><a class="nav-word-item" href="/">主页</a><a class="nav-word-item" href="/archives">归档</a><a class="nav-word-item" href="/tags">标签</a><a class="nav-word-item" href="/categories">分类</a><a class="nav-word-item" href="/about">关于</a></div><div id="nav-list"><ul><li><a class="nav-list-item" href="/">主页</a></li><li><a class="nav-list-item" href="/archives">归档</a></li><li><a class="nav-list-item" href="/tags">标签</a></li><li><a class="nav-list-item" href="/categories">分类</a></li><li><a class="nav-list-item" href="/about">关于</a></li></ul></div></nav><div id="banner-wrapper"><div id="banner-pagetype-dependent-info"><h1 id="post-title">Swift中的Extension</h1><span id="post-description"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-05-09</span><span id="word-count">全文共 1673 字</span><span id="time-count">需阅读时间约 6 分钟</span></div></div><a title="回到顶部"><i class="fa fa-arrow-up" id="to-Top" aria-hidden="true"></i></a><a title="点击关闭目录"><i class="fa fa-toggle-on" id="toggle-on-Toc" aria-hidden="true"></i></a><a title="点击展开目录"><i class="fa fa-toggle-off" id="toggle-off-Toc" aria-hidden="true"></i></a></header><aside id="toc-column"><div id="toc-column-inner-wrapper"><div id="post-toc"><ol class="toc"><li class="toc-item toc-level-4"><a class="toc-link" href="#一、添加计算型属性、计算型静态属性、“存储属性”"><span class="toc-text">一、添加计算型属性、计算型静态属性、“存储属性”</span></a></li></ol></div></div></aside><main id="main-content-column"><div id="main-content-wrapper"><div id="post-full-content"><p>Swift中可以对类，结构体，协议，枚举进行拓展添加新的功能<br>考虑到本篇博文中的篇幅，关于枚举的拓展将在下一篇介绍<code>ps:</code>基于Swift 5<br>Swift 中的扩展可以：</p>
<ul>
<li>一、添加计算型属性和计算型静态属性</li>
<li>二、定义实例方法和类型方法</li>
<li>三、提供新的构造器</li>
<li>四、定义下标</li>
<li>五、定义和使用新的嵌套类型</li>
<li>六、使一个已有类型符合某个协议<a id="more"></a>
<h4 id="一、添加计算型属性、计算型静态属性、“存储属性”"><a href="#一、添加计算型属性、计算型静态属性、“存储属性”" class="headerlink" title="一、添加计算型属性、计算型静态属性、“存储属性”"></a>一、添加计算型属性、计算型静态属性、“存储属性”</h4><pre><code>class Animal:NSObject {
  var age:Int?
}
</code></pre></li>
</ul>
<p>private var animalName:String = “”<br>extension Animal {<br>    //1添加静态计算属性<br>    static var c:Int{<br>        get {<br>            print(“get c”)<br>            return 3<br>        }<br>        set{<br>            print(“set c:(newValue)”)<br>        }<br>    }<br>    //2添加计算属性<br>    var isAdult:Bool{<br>        get{<br>            return self.age ?? 0 &gt; 2<br>        }<br>        set{<br>            if newValue {<br>                self.age = 2<br>            }else{<br>                self.age = 0<br>            }<br>        }<br>    }<br>    //3使用AssociatedObject添加存储属性<br>    var name:String {<br>        get{<br>            return objc_getAssociatedObject(self, &amp;animalName) as! String<br>        }<br>        set{<br>            objc_setAssociatedObject(self, &amp;animalName, newValue, .OBJC_ASSOCIATION_ASSIGN)<br>        }<br>    }</p>
<p>}</p>
<pre><code>调用示例</code></pre><p>let animal = Animal()<br>animal.age = 3<br>print(“(animal.age)”)//Optional(3)<br>animal.name = “AA”<br>animal.isAdult = true<br>print(“—–”)<br>print(“(animal.age)”)//Optional(2)<br>print(“(animal.name)”)//AA<br>Animal.c = 6<br>print(Animal.c)</p>
<pre><code>![调用结果](https://upload-images.jianshu.io/upload_images/6695792-ce68ac37a0fe7081.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
1，这里需要解释一下官方文档中虽然介绍`extension`不能添加存储属性，但是依旧可以利用`AssociatedObject`来达到添加存储属性的效果
2，在类和结构体中添加计算属性，“存储属性”可以按照以上方式，但是在`protocol`中又会是何种情况呢？我们知道`protocol`中可以定义属性和方法，而遵循该`protocol`的类或结构体就必须实现其中的方法，添加其中的属性（Optional除外）。如果在定义`protocol`时并没有申明子类必须添加某个属性，而你通过拓展添加了一个存储属性，那你之前遵循过此协议的子类岂不是都不能编译通过了。因此在拓展协议时只能添加`Optional`属性。
##### 在协议中添加`optional`属性</code></pre><p>protocol P{<br>    var name:String{ get set}</p>
<p>}<br>extension P{<br>    //添加静态计算属性<br>    static var c:Int{<br>        get {<br>            print(“get c”)<br>            return 3<br>        }<br>        set{<br>            print(“set c:(newValue)”)<br>        }<br>    }<br>    //添加计算属性<br>    var temp:Bool{<br>        get{<br>            return true<br>        }</p>
<pre><code>    set{
        print(&quot;set temp:\(newValue)&quot;)
    }
}
//使用AssociatedObject添加存储属性
var words:String? {
    get{
        return objc_getAssociatedObject(self, &amp;animalName) as? String
    }
    set{
        objc_setAssociatedObject(self, &amp;animalName, newValue, .OBJC_ASSOCIATION_ASSIGN)
    }
}</code></pre><p>}</p>
<p>class B : P{<br>    var name: String = “”</p>
<p>}</p>
<pre><code>![调用结果](https://upload-images.jianshu.io/upload_images/6695792-5469438a0298656d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

#### 二、定义实例方法和类型方法</code></pre><p>extension String {<br>    func fetchDate(_ format :String = “YYYY-MM-dd HH:mm:ss”) -&gt;Date?{<br>        let  dateFormater = DateFormatter.init()<br>        dateFormater.dateFormat = format</p>
<pre><code>    let date = dateFormater.date(from: self)
    return date
}</code></pre><p>}</p>
<pre><code>1，在结构体和类中添加拓展方法应该是日常开发中最为常见的
2，在拓展类时添加实例方法既可以用`class`修饰也可以使用`static`修饰，而在结构体和协议中只能使用`static`修饰，因为`Class methods are only allowed within classes`
#### 三、提供新的构造器
##### 1，给结构体添加新的构造器</code></pre><p>struct H{<br>    var num1:Int?<br>    var num2:Int?<br>}</p>
<p>extension H{<br>    init(num1:Int,num2:Int) {<br>        self.num1 = num1<br>        self.num2 = num2<br>    }</p>
<pre><code>init(num1:Int){
    self.num1 = num1
}</code></pre><p>}<br>let h = H(num1: 2, num2: 3)<br>print(h.num1)//Optional(2)<br>print(h.num2)//Optional(3)</p>
<pre><code>![结构体构造函数](https://upload-images.jianshu.io/upload_images/6695792-20ba07afe643a20b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
从上图的代码提示中可以看到`struct` `H`在初始化时有系统默认生成的一个无参构造函数和一个带有所有属性的构造函数，以及我们在`extension`中添加的两个构造函数
##### 2，给类添加新的构造器</code></pre><p>extension UIColor{<br>    /// hexColor<br>    convenience init(hex: String , alpha: CGFloat = 1) {<br>            let scanner = Scanner(string: hex)<br>            scanner.scanLocation = 0</p>
<pre><code>        var rgbValue: UInt64 = 0

        scanner.scanHexInt64(&amp;rgbValue)

        let r = (rgbValue &amp; 0xff0000) &gt;&gt; 16
        let g = (rgbValue &amp; 0xff00) &gt;&gt; 8
        let b = rgbValue &amp; 0xff

        self.init(
            red: CGFloat(r) / 0xff,
            green: CGFloat(g) / 0xff,
            blue: CGFloat(b) / 0xff, alpha: alpha
        )
}</code></pre><p>}</p>
<pre><code>与`struct`不同的是在拓展类时只能添加便利构造器
#### 四、定义下标</code></pre><p>extension String<br>{<br>    /// 返回索引为index的字符，未找到返回空<br>    subscript(index: Int) -&gt; String {<br>        let range = 0…self.count - 1<br>        if range.contains(index){<br>            let s = self.index(startIndex, offsetBy: index)<br>            let e = self.index(startIndex, offsetBy: index + 1)<br>            return String(self[s..&lt;e])<br>        }<br>        return “”<br>    }<br>}</p>
<p>let str1 = “12345”<br>print(str1[-3])// “”<br>print(str1[3])// “4”</p>
<pre><code>类同理</code></pre><p>class People{</p>
<p>}</p>
<p>extension People{<br>    subscript(index: Int) -&gt; String {</p>
<pre><code>    return &quot;AA&quot;
}
subscript(a:String,b:Int) -&gt; Int{
    return 3
}</code></pre><p>}<br>let p = People()<br>print(p[2])//AA<br>print(p[“SS”,0])//3</p>
<pre><code>`ps:`对于类拓展下标的功能写完我真的是给`Swift`跪了,可以自定义参数，自定义返回值。上面拓展`String`的下标访问还可以理解，对于给类添加下标访问方法目前我还没有发现有什么妙用，如果有什么好案例还望不吝赐教。
#### 五、定义嵌套类型</code></pre><p>class People{</p>
<p>}</p>
<p>extension People{<br>    enum gender{<br>        case man<br>        case woman<br>    }<br>}<br>// 使用<br>People.gender.man</p>
<pre><code>#### 六、使一个已有类型符合某个协议</code></pre><p>extension MAOrderListSecondViewController :UITableViewDelegate,UITableViewDataSource{</p>
<pre><code>func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int {
    return dataSource.count
}

func tableView(_ tableView: UITableView, heightForRowAt indexPath: IndexPath) -&gt; CGFloat {
    return UITableView.automaticDimension
}
//....</code></pre><p>}</p>
<pre><code>在开发中我经常将某个类需要遵循的协议使用`extension`分割开来以提高代码的可读性
#### 七、拓展协议添加`where`从句</code></pre><p>protocol MAViewProtocol {</p>
<p>}</p>
<p>extension MAViewProtocol where Self:UIView{<br>    func getString() -&gt; String{<br>        return “String”<br>    }<br>}</p>
<p>class MATestColor:UIColor,MAViewProtocol{</p>
<p>}</p>
<p>class MATestView:UIView,MAViewProtocol {</p>
<p>}</p>
<p>let view = MATestView()<br>view.getString()<br>let color = MATestColor()<br>color.getString()</p>
<pre><code>上面的代码段中`color.getString()`是无法通过编译的。首先我在`MAViewProtocol`的拓展中添加了`getString()`方法虽然`MATestColor`和`MATestView`都遵循了`MAViewProtocol`，但是我在拓展时添加了`where`从句`where Self:UIView`。意思为只有是`UIView`的子类才能使用该拓展中的方法，而`MATestColor`继承自`UIColor`因此无法调用`getString()`方法
#### 八、通过拓展协议实现命名空间
从事iOS开发的同学应该不会对`Kingfisher`中的`kf`,`RxSwift`中`rx`感到陌生</code></pre><p>public struct Reactive<Base> {<br>    /// Base object to extend.<br>    public let base: Base</p>
<pre><code>/// Creates extensions with base object.
///
/// - parameter base: Base object.
public init(_ base: Base) {
    self.base = base
}</code></pre><p>}</p>
<p>/// A type that has reactive extensions.<br>public protocol ReactiveCompatible {<br>    /// Extended type<br>    associatedtype ReactiveBase</p>
<pre><code>@available(*, deprecated, renamed: &quot;ReactiveBase&quot;)
typealias CompatibleType = ReactiveBase

/// Reactive extensions.
static var rx: Reactive&lt;ReactiveBase&gt;.Type { get set }

/// Reactive extensions.
var rx: Reactive&lt;ReactiveBase&gt; { get set }</code></pre><p>}</p>
<p>extension ReactiveCompatible {<br>    /// Reactive extensions.<br>    public static var rx: Reactive<Self>.Type {<br>        get {<br>            return Reactive<Self>.self<br>        }<br>        // swiftlint:disable:next unused_setter_value<br>        set {<br>            // this enables using Reactive to “mutate” base type<br>        }<br>    }</p>
<pre><code>/// Reactive extensions.
public var rx: Reactive&lt;Self&gt; {
    get {
        return Reactive(self)
    }
    // swiftlint:disable:next unused_setter_value
    set {
        // this enables using Reactive to &quot;mutate&quot; base object
    }
}</code></pre><p>}</p>
<pre><code>这段代码是从`RxSwift`框架中截取出来，目前对于我来说只是知其然不知其所以然，后续再慢慢深究吧。
&gt; 参考文献
&gt;[https://docs.swift.org/swift-book/LanguageGuide/Extensions.html#//apple_ref/doc/uid/TP40014097-CH24-ID152](https://docs.swift.org/swift-book/LanguageGuide/Extensions.html#//apple_ref/doc/uid/TP40014097-CH24-ID152)
&gt;[https://www.runoob.com/swift/swift-extensions.html](https://www.runoob.com/swift/swift-extensions.html)</code></pre></div><div id="post-tags-container"><i class="fa fa-tags"></i> <a class="post-tag" href="/tags/Swift/">#Swift</a>  <a class="post-tag" href="/tags/Extension/">#Extension</a></div><div id="post-categories-container"><i class="fa fa-folder-open"></i>
 <a href="/categories/Swift/">Swift</a></div></div></main><div id="pagination-wrapper"><a id="page-prev" href="/2020/05/17/2020/05/AppStoreTransition/"><i class="fa fa-chevron-left"></i> 仿App Store转场动画 Swift语言实现</a><a id="page-next" href="/2020/04/30/2020/04/moyawrap/">Moya网络请求封装 <i class="fa fa-chevron-right"></i></a></div><footer id="page-footer"><div id="footer-wrapper"><div id="blog-meta">&copy;2017-2020 By AidaHe | 主题 - <a id='theme-name' href="https://github.com/huan555/lemon-lime" target="_blank" rel="noopener"> Lemon-Lime</a> | 驱动 - <a id='theme-powered-by' href=http://hexo.io> Hexo</a></div><div id="viewed-record"><script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-eye" aria-hidden="true"></i> <span id="busuanzi_value_page_pv"></span></span></div><div id="copyright-wrapper"><i class="fa fa-cc" aria-hidden="true"></i><div id="copyright">除非有特别声明，本博客所有文章均采用 <a rel="license" href=http://creativecommons.org/licenses/by-nc-sa/4.0/>CC BY-NC-SA 4.0 协议</a>.</div></div><div id="contact-me"><div id="rss"><a href="/atom.xml" type="application/atom+xml" rel="alternate" target="_blank"><i class="fa fa-rss" aria-hidden="true"></i></a></div><span id="github"><a href="https://github.com/AidaHe" target="_blank" rel="noopener"><i class="fa fa-github" aria-hidden="true"></i></a></span></div></div></footer><script src="/compass/js/blog.js"></script><!--script(src='/compass/js/prism.js')--></div></body>