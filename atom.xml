<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>AidaHe‘s blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-05-18T13:39:46.973Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>AidaHe</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>仿App Store转场动画 Swift语言实现</title>
    <link href="http://yoursite.com/2020/05/17/2020/05/AppStoreTransition/"/>
    <id>http://yoursite.com/2020/05/17/2020/05/AppStoreTransition/</id>
    <published>2020-05-17T02:38:00.000Z</published>
    <updated>2020-05-18T13:39:46.973Z</updated>
    
    <content type="html"><![CDATA[<h3 id="参考文档："><a href="#参考文档：" class="headerlink" title="参考文档："></a>参考文档：</h3><blockquote><p><a href="https://www.jianshu.com/p/d802eb2e5a31" target="_blank" rel="noopener">https://www.jianshu.com/p/d802eb2e5a31</a><br>本文主体思路是参考该博主的OC版本实现的<br><a href="https://www.jianshu.com/p/8a99020d954f" target="_blank" rel="noopener">https://www.jianshu.com/p/8a99020d954f</a><br>此文章介绍了转场动画中相关的一些概念，我感觉还是挺通俗易懂的。</p></blockquote><h3 id="效果图："><a href="#效果图：" class="headerlink" title="效果图："></a>效果图：</h3><p><img src="https://upload-images.jianshu.io/upload_images/6695792-899f9bb7318751e1.gif?imageMogr2/auto-orient/strip" alt="效果图"></p><a id="more"></a><h3 id="场景分析："><a href="#场景分析：" class="headerlink" title="场景分析："></a>场景分析：</h3><p>1、某日，我看到App Store上首页花里胡哨的转场动画体验着实不错，便想着自己实现一番。<br>2、作为一个萌新看到这样的效果完全联想不到是用何等操作实现的，so，百度，于是找到一个OC版。<br>3、然后也知道此效果主要是通过重写系统的<code>push</code>、<code>pop</code>动画达到的。作为一个<code>Swift</code>偏好者，难免不想翻译一下。<br>4、既然是需要<code>push</code>、<code>pop</code>，那么第一步是需要<code>navigationController</code>，我是直接在<code>StoryBoard</code>中嵌入的。<br>5、接下来是首页<code>TableView</code>布局，<code>cell</code>触摸缩小放大。<br>6、点击<code>cell Push</code>到详情页，本文重点，先放到后面再详说。<br>7、详情页依旧是<code>TableView</code>布局。顶部大图为<code>Header</code>，底部为文本，动态计算高度即可。<br>8、详情页伴随着左滑手势将页面按一定比例缩小，当缩小一定程度时<code>Pop</code>回首页。<br>9、不难发现，在详情页左滑时还有一个模糊的背景正是首页的截图。</p><h3 id="代码实现："><a href="#代码实现：" class="headerlink" title="代码实现："></a>代码实现：</h3><p>除了不知道如何重写<code>pop</code>和<code>push</code>之外其余思路清晰之后，便可以开始绘制基本UI了<br><img src="https://upload-images.jianshu.io/upload_images/6695792-f666c487494066c5.gif?imageMogr2/auto-orient/strip" alt="系统push、pop效果"></p><h4 id="一、重写Push、实现Delegate"><a href="#一、重写Push、实现Delegate" class="headerlink" title="一、重写Push、实现Delegate"></a>一、重写Push、实现Delegate</h4><pre><code class="(Swift)">extension ViewController:UINavigationControllerDelegate,UIViewControllerAnimatedTransitioning{    func transitionDuration(using transitionContext: UIViewControllerContextTransitioning?) -&gt; TimeInterval {        return 1.0    }    func navigationController(_ navigationController: UINavigationController, animationControllerFor operation: UINavigationController.Operation, from fromVC: UIViewController, to toVC: UIViewController) -&gt; UIViewControllerAnimatedTransitioning?{        return self    }    func animateTransition(using transitionContext: UIViewControllerContextTransitioning) {    }}</code></pre><p>此时我们再来仔细观察从首页点击<code>cell</code>之后<code>push</code>到详情页这之间发生了什么？不难发现，其实就是将<code>cell</code>放大，有一种弹出的效果，而系统的<code>push</code>默认效果是新页面从左边覆盖过来。</p><blockquote><p>其实呢，在转场的过程中系统会提供一个视图容器用来盛装进行跳转控制器的视图，如下图所示，当前的<code>FirstViewController</code> <code>present</code>到<code>SecondViewController</code>的时候，此时，<code>FirstViewController</code>的<code>view</code>变成<code>fromView</code>，这个视图会自动加入到<code>transtition container view</code>中，然后在跳转过程中我们需要做的就是将<code>SecondViewController</code>的视图（此时是toView）加入到这个容器中，然后为这个toView的展现增加动画。<br>以上内容摘录自此处<br>作者：劉光軍_Shine<br>链接：<a href="https://www.jianshu.com/p/8a99020d954f" target="_blank" rel="noopener">https://www.jianshu.com/p/8a99020d954f</a><br>來源：简书</p></blockquote><p>有了一定概念之后，我们来解读一下下面的逻辑<br>1、拿到<code>toView</code>:即将要展示的视图，<code>fromView</code>:当前页面已展示的<code>view</code><br>2、拿到<code>toView,fromView</code>之后，即将要展示动画，先将<code>fromView</code>隐藏，操作<code>toView</code>的<code>frame</code>和<code>alpha</code>以达到弹出放大的效果<br>3、将需要展示动画的<code>view</code>设置相应位置之后添加到<code>transitionContext</code>中<br>4、展示动画<code>toView.alpha 0~&gt;1</code> 逐渐显示，<code>frame</code> 首页<code>cell frame~&gt;</code> 详情页<code>header frame</code> 逐渐放大<br>5、移除用于展示动画的<code>view</code>，显示详情页<code>view</code>，显示首页<code>view</code></p><pre><code class="Swift">func animateTransition(using transitionContext: UIViewControllerContextTransitioning) {        let cell:HomeTableViewCell = tableView.cellForRow(at: selectIndexPath!) as! HomeTableViewCell        let toVC:UIViewController = transitionContext.viewController(forKey: .to)!        let toView:UIImageView = toVC.value(forKeyPath:&quot;headerImageView&quot;) as! UIImageView        let fromView = cell.bgView        let containerView = transitionContext.containerView        let snapshotView = UIImageView(image: cell.bgImageView!.image)        snapshotView.frame = containerView.convert((fromView?.frame)!, from: fromView?.superview)        fromView?.isHidden = true        toVC.view.frame = transitionContext.finalFrame(for: toVC)        toVC.view.alpha = 0        toView.isHidden = true        let titleLabel = UILabel(frame: CGRect(x: 15, y: 20, width: kScreenWidth-30, height: 30))        titleLabel.textColor = UIColor.white        titleLabel.font = UIFont.boldSystemFont(ofSize: 25)        titleLabel.text = cell.titleLabel?.text        let contentLabel = UILabel(frame: CGRect(x: 15, y: (kScreenWidth-40)*1.3-30, width: kScreenWidth-30, height: 15))        contentLabel.textColor = UIColor.white        contentLabel.text = cell.contentLabel?.text        contentLabel.font = UIFont(name: &quot;PingFangSC-Light&quot;, size: 15)        contentLabel.alpha = 0.5        snapshotView.addSubview(titleLabel)        snapshotView.addSubview(contentLabel)        containerView.addSubview(toVC.view)        containerView.addSubview(snapshotView)        UIView.animate(withDuration: self.transitionDuration(using: transitionContext), delay: 0.0, usingSpringWithDamping: 0.6, initialSpringVelocity: 1.0, options: .curveLinear, animations: {                    containerView.layoutIfNeeded()                    toVC.view.alpha = 1.0                    self.view.frame = CGRect(x: 0, y: 0, width: kScreenWidth, height: kScreenHeight)                    snapshotView.frame = containerView.convert(toView.frame, from: toView.superview)                    titleLabel.frame = CGRect(x: 22, y: 30, width: kScreenWidth - 30, height: 30)                    contentLabel.frame = CGRect(x: 22, y: kScreenWidth*1.3-30, width: kScreenWidth*1.3-44, height: 15)                }) { (finished) in                    toView.isHidden = false                    fromView?.isHidden = false                    snapshotView.removeFromSuperview()                    self.tableView.reloadData()                    transitionContext.completeTransition(true)                }    }</code></pre><h4 id="二、将首页截图传递给详情页备用"><a href="#二、将首页截图传递给详情页备用" class="headerlink" title="二、将首页截图传递给详情页备用"></a>二、将首页截图传递给详情页备用</h4><pre><code class="(swift)">//MARK: 截屏    func imageFromView() -&gt;UIImage{        UIGraphicsBeginImageContext(self.view.frame.size)        let context = UIGraphicsGetCurrentContext()        self.view.layer.render(in: context!)        let image = UIGraphicsGetImageFromCurrentImageContext()        UIGraphicsEndImageContext()        return image!    }</code></pre><h4 id="三、详情页添加左滑返回手势"><a href="#三、详情页添加左滑返回手势" class="headerlink" title="三、详情页添加左滑返回手势"></a>三、详情页添加左滑返回手势</h4><p>1、给详情页的<code>tableView</code>添加手势<br>2、滑动过程中，实时获取当前滑动位置到初始位置的距离，实时计算该距离占据屏幕比例，相应缩小<code>tableView</code>大小并添加适应的圆角<br>3、手势结束时，获取手势发生的开始位置，手势结束后获取结束位置，计算出总共滑动范围<br>4、依据滑动范围所占屏幕的比例从而决定是否<code>pop</code>回上一页。若比例达到返回上一页，重写<code>pop</code>动画与<code>push</code>类似。若比例未达到，恢复详情页<code>tableView frame</code></p><pre><code class="(swift)">@objc func handleGesture(_ sender:UIGestureRecognizer){        weak var weakSelf = self        switch sender.state {        case .began:            print(&quot;手势开始---&quot;)            let currentPoint = sender.location(in: self.detailTableView)            startPointX = currentPoint.x            startPointY = currentPoint.y            isHorizontal = (startPointX &gt; CGFloat(30)) ? false : true            break        case .changed:            print(&quot;拖动中----&quot;)            let currentPoint = sender.location(in: self.detailTableView)            if isHorizontal {                if ((currentPoint.x-startPointX)&gt;(currentPoint.y-startPointY)) {                    scale = (kScreenWidth-(currentPoint.x-startPointX))/kScreenWidth                } else {                    scale = (kScreenHeight-(currentPoint.y-startPointY))/kScreenHeight                }            } else {                scale = (kScreenHeight-(currentPoint.y-startPointY))/kScreenHeight            }            if (scale &gt; CGFloat(1)) {                scale = CGFloat(1)            } else if (scale &lt;= CGFloat(0.8)) {                scale = CGFloat(0.8);            }            if (self.detailTableView!.contentOffset.y&lt;=0) {                // 缩放                self.detailTableView!.transform = CGAffineTransform(scaleX: scale, y: scale)                // 圆角                self.detailTableView!.layer.cornerRadius = 15 * (1-scale)*5*1.08;            }            self.detailTableView!.isScrollEnabled = (scale &lt; 0.99) ? false : true            break        case .ended:            print(&quot;手势结束--&quot;)            if(scale == 0.8){                DispatchQueue.main.asyncAfter(deadline: .now()+0.5) {                    weakSelf?.navigationController?.popViewController(animated: true)                }            }            self.detailTableView!.isScrollEnabled = true            if scale &gt; CGFloat(0.8) {                UIView.animate(withDuration: 0.2) {                    weakSelf?.detailTableView!.layer.cornerRadius = 0                    weakSelf?.detailTableView!.transform = CGAffineTransform(scaleX: 1, y: 1)                }            }            break        default:            break        }</code></pre><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>1、如果实际开发中多处需要用到这种转场效果可以抽出一个工具类来。<br>2、其实<code>App Store</code>中<code>pop</code>回来还有一个效果就是返回到首页时下面的文字说明会像一个抽屉一样由下往上收回的效果，有时间再去研究一下。另外，<code>App Store</code>上的背景配色之类一些细节处理也是非常极致的，有兴趣的朋友可以继续深究。<br>3、如有不足之处，望各路大神斧正。<br>4、<a href="https://github.com/SingletonH/SwiftTransition.git" target="_blank" rel="noopener">源码地址：https://github.com/SingletonH/SwiftTransition.git</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;参考文档：&quot;&gt;&lt;a href=&quot;#参考文档：&quot; class=&quot;headerlink&quot; title=&quot;参考文档：&quot;&gt;&lt;/a&gt;参考文档：&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://www.jianshu.com/p/d802eb2e5a31&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.jianshu.com/p/d802eb2e5a31&lt;/a&gt;&lt;br&gt;本文主体思路是参考该博主的OC版本实现的&lt;br&gt;&lt;a href=&quot;https://www.jianshu.com/p/8a99020d954f&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.jianshu.com/p/8a99020d954f&lt;/a&gt;&lt;br&gt;此文章介绍了转场动画中相关的一些概念，我感觉还是挺通俗易懂的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;效果图：&quot;&gt;&lt;a href=&quot;#效果图：&quot; class=&quot;headerlink&quot; title=&quot;效果图：&quot;&gt;&lt;/a&gt;效果图：&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/6695792-899f9bb7318751e1.gif?imageMogr2/auto-orient/strip&quot; alt=&quot;效果图&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Swift" scheme="http://yoursite.com/categories/Swift/"/>
    
    
      <category term="Swift" scheme="http://yoursite.com/tags/Swift/"/>
    
      <category term="App Store" scheme="http://yoursite.com/tags/App-Store/"/>
    
      <category term="Transition" scheme="http://yoursite.com/tags/Transition/"/>
    
  </entry>
  
  <entry>
    <title>Swift中的Extension</title>
    <link href="http://yoursite.com/2020/05/09/2020/05/SwiftExtension/"/>
    <id>http://yoursite.com/2020/05/09/2020/05/SwiftExtension/</id>
    <published>2020-05-09T11:31:00.000Z</published>
    <updated>2020-05-09T11:39:39.547Z</updated>
    
    <content type="html"><![CDATA[<p>Swift中可以对类，结构体，协议，枚举进行拓展添加新的功能<br>考虑到本篇博文中的篇幅，关于枚举的拓展将在下一篇介绍<code>ps:</code>基于Swift 5<br>Swift 中的扩展可以：</p><ul><li>一、添加计算型属性和计算型静态属性</li><li>二、定义实例方法和类型方法</li><li>三、提供新的构造器</li><li>四、定义下标</li><li>五、定义和使用新的嵌套类型</li><li>六、使一个已有类型符合某个协议<a id="more"></a><h4 id="一、添加计算型属性、计算型静态属性、“存储属性”"><a href="#一、添加计算型属性、计算型静态属性、“存储属性”" class="headerlink" title="一、添加计算型属性、计算型静态属性、“存储属性”"></a>一、添加计算型属性、计算型静态属性、“存储属性”</h4><pre><code>class Animal:NSObject {  var age:Int?}</code></pre></li></ul><p>private var animalName:String = “”<br>extension Animal {<br>    //1添加静态计算属性<br>    static var c:Int{<br>        get {<br>            print(“get c”)<br>            return 3<br>        }<br>        set{<br>            print(“set c:(newValue)”)<br>        }<br>    }<br>    //2添加计算属性<br>    var isAdult:Bool{<br>        get{<br>            return self.age ?? 0 &gt; 2<br>        }<br>        set{<br>            if newValue {<br>                self.age = 2<br>            }else{<br>                self.age = 0<br>            }<br>        }<br>    }<br>    //3使用AssociatedObject添加存储属性<br>    var name:String {<br>        get{<br>            return objc_getAssociatedObject(self, &amp;animalName) as! String<br>        }<br>        set{<br>            objc_setAssociatedObject(self, &amp;animalName, newValue, .OBJC_ASSOCIATION_ASSIGN)<br>        }<br>    }</p><p>}</p><pre><code>调用示例</code></pre><p>let animal = Animal()<br>animal.age = 3<br>print(“(animal.age)”)//Optional(3)<br>animal.name = “AA”<br>animal.isAdult = true<br>print(“—–”)<br>print(“(animal.age)”)//Optional(2)<br>print(“(animal.name)”)//AA<br>Animal.c = 6<br>print(Animal.c)</p><pre><code>![调用结果](https://upload-images.jianshu.io/upload_images/6695792-ce68ac37a0fe7081.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)1，这里需要解释一下官方文档中虽然介绍`extension`不能添加存储属性，但是依旧可以利用`AssociatedObject`来达到添加存储属性的效果2，在类和结构体中添加计算属性，“存储属性”可以按照以上方式，但是在`protocol`中又会是何种情况呢？我们知道`protocol`中可以定义属性和方法，而遵循该`protocol`的类或结构体就必须实现其中的方法，添加其中的属性（Optional除外）。如果在定义`protocol`时并没有申明子类必须添加某个属性，而你通过拓展添加了一个存储属性，那你之前遵循过此协议的子类岂不是都不能编译通过了。因此在拓展协议时只能添加`Optional`属性。##### 在协议中添加`optional`属性</code></pre><p>protocol P{<br>    var name:String{ get set}</p><p>}<br>extension P{<br>    //添加静态计算属性<br>    static var c:Int{<br>        get {<br>            print(“get c”)<br>            return 3<br>        }<br>        set{<br>            print(“set c:(newValue)”)<br>        }<br>    }<br>    //添加计算属性<br>    var temp:Bool{<br>        get{<br>            return true<br>        }</p><pre><code>    set{        print(&quot;set temp:\(newValue)&quot;)    }}//使用AssociatedObject添加存储属性var words:String? {    get{        return objc_getAssociatedObject(self, &amp;animalName) as? String    }    set{        objc_setAssociatedObject(self, &amp;animalName, newValue, .OBJC_ASSOCIATION_ASSIGN)    }}</code></pre><p>}</p><p>class B : P{<br>    var name: String = “”</p><p>}</p><pre><code>![调用结果](https://upload-images.jianshu.io/upload_images/6695792-5469438a0298656d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)#### 二、定义实例方法和类型方法</code></pre><p>extension String {<br>    func fetchDate(_ format :String = “YYYY-MM-dd HH:mm:ss”) -&gt;Date?{<br>        let  dateFormater = DateFormatter.init()<br>        dateFormater.dateFormat = format</p><pre><code>    let date = dateFormater.date(from: self)    return date}</code></pre><p>}</p><pre><code>1，在结构体和类中添加拓展方法应该是日常开发中最为常见的2，在拓展类时添加实例方法既可以用`class`修饰也可以使用`static`修饰，而在结构体和协议中只能使用`static`修饰，因为`Class methods are only allowed within classes`#### 三、提供新的构造器##### 1，给结构体添加新的构造器</code></pre><p>struct H{<br>    var num1:Int?<br>    var num2:Int?<br>}</p><p>extension H{<br>    init(num1:Int,num2:Int) {<br>        self.num1 = num1<br>        self.num2 = num2<br>    }</p><pre><code>init(num1:Int){    self.num1 = num1}</code></pre><p>}<br>let h = H(num1: 2, num2: 3)<br>print(h.num1)//Optional(2)<br>print(h.num2)//Optional(3)</p><pre><code>![结构体构造函数](https://upload-images.jianshu.io/upload_images/6695792-20ba07afe643a20b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)从上图的代码提示中可以看到`struct` `H`在初始化时有系统默认生成的一个无参构造函数和一个带有所有属性的构造函数，以及我们在`extension`中添加的两个构造函数##### 2，给类添加新的构造器</code></pre><p>extension UIColor{<br>    /// hexColor<br>    convenience init(hex: String , alpha: CGFloat = 1) {<br>            let scanner = Scanner(string: hex)<br>            scanner.scanLocation = 0</p><pre><code>        var rgbValue: UInt64 = 0        scanner.scanHexInt64(&amp;rgbValue)        let r = (rgbValue &amp; 0xff0000) &gt;&gt; 16        let g = (rgbValue &amp; 0xff00) &gt;&gt; 8        let b = rgbValue &amp; 0xff        self.init(            red: CGFloat(r) / 0xff,            green: CGFloat(g) / 0xff,            blue: CGFloat(b) / 0xff, alpha: alpha        )}</code></pre><p>}</p><pre><code>与`struct`不同的是在拓展类时只能添加便利构造器#### 四、定义下标</code></pre><p>extension String<br>{<br>    /// 返回索引为index的字符，未找到返回空<br>    subscript(index: Int) -&gt; String {<br>        let range = 0…self.count - 1<br>        if range.contains(index){<br>            let s = self.index(startIndex, offsetBy: index)<br>            let e = self.index(startIndex, offsetBy: index + 1)<br>            return String(self[s..&lt;e])<br>        }<br>        return “”<br>    }<br>}</p><p>let str1 = “12345”<br>print(str1[-3])// “”<br>print(str1[3])// “4”</p><pre><code>类同理</code></pre><p>class People{</p><p>}</p><p>extension People{<br>    subscript(index: Int) -&gt; String {</p><pre><code>    return &quot;AA&quot;}subscript(a:String,b:Int) -&gt; Int{    return 3}</code></pre><p>}<br>let p = People()<br>print(p[2])//AA<br>print(p[“SS”,0])//3</p><pre><code>`ps:`对于类拓展下标的功能写完我真的是给`Swift`跪了,可以自定义参数，自定义返回值。上面拓展`String`的下标访问还可以理解，对于给类添加下标访问方法目前我还没有发现有什么妙用，如果有什么好案例还望不吝赐教。#### 五、定义嵌套类型</code></pre><p>class People{</p><p>}</p><p>extension People{<br>    enum gender{<br>        case man<br>        case woman<br>    }<br>}<br>// 使用<br>People.gender.man</p><pre><code>#### 六、使一个已有类型符合某个协议</code></pre><p>extension MAOrderListSecondViewController :UITableViewDelegate,UITableViewDataSource{</p><pre><code>func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int {    return dataSource.count}func tableView(_ tableView: UITableView, heightForRowAt indexPath: IndexPath) -&gt; CGFloat {    return UITableView.automaticDimension}//....</code></pre><p>}</p><pre><code>在开发中我经常将某个类需要遵循的协议使用`extension`分割开来以提高代码的可读性#### 七、拓展协议添加`where`从句</code></pre><p>protocol MAViewProtocol {</p><p>}</p><p>extension MAViewProtocol where Self:UIView{<br>    func getString() -&gt; String{<br>        return “String”<br>    }<br>}</p><p>class MATestColor:UIColor,MAViewProtocol{</p><p>}</p><p>class MATestView:UIView,MAViewProtocol {</p><p>}</p><p>let view = MATestView()<br>view.getString()<br>let color = MATestColor()<br>color.getString()</p><pre><code>上面的代码段中`color.getString()`是无法通过编译的。首先我在`MAViewProtocol`的拓展中添加了`getString()`方法虽然`MATestColor`和`MATestView`都遵循了`MAViewProtocol`，但是我在拓展时添加了`where`从句`where Self:UIView`。意思为只有是`UIView`的子类才能使用该拓展中的方法，而`MATestColor`继承自`UIColor`因此无法调用`getString()`方法#### 八、通过拓展协议实现命名空间从事iOS开发的同学应该不会对`Kingfisher`中的`kf`,`RxSwift`中`rx`感到陌生</code></pre><p>public struct Reactive<Base> {<br>    /// Base object to extend.<br>    public let base: Base</p><pre><code>/// Creates extensions with base object.////// - parameter base: Base object.public init(_ base: Base) {    self.base = base}</code></pre><p>}</p><p>/// A type that has reactive extensions.<br>public protocol ReactiveCompatible {<br>    /// Extended type<br>    associatedtype ReactiveBase</p><pre><code>@available(*, deprecated, renamed: &quot;ReactiveBase&quot;)typealias CompatibleType = ReactiveBase/// Reactive extensions.static var rx: Reactive&lt;ReactiveBase&gt;.Type { get set }/// Reactive extensions.var rx: Reactive&lt;ReactiveBase&gt; { get set }</code></pre><p>}</p><p>extension ReactiveCompatible {<br>    /// Reactive extensions.<br>    public static var rx: Reactive<Self>.Type {<br>        get {<br>            return Reactive<Self>.self<br>        }<br>        // swiftlint:disable:next unused_setter_value<br>        set {<br>            // this enables using Reactive to “mutate” base type<br>        }<br>    }</p><pre><code>/// Reactive extensions.public var rx: Reactive&lt;Self&gt; {    get {        return Reactive(self)    }    // swiftlint:disable:next unused_setter_value    set {        // this enables using Reactive to &quot;mutate&quot; base object    }}</code></pre><p>}</p><pre><code>这段代码是从`RxSwift`框架中截取出来，目前对于我来说只是知其然不知其所以然，后续再慢慢深究吧。&gt; 参考文献&gt;[https://docs.swift.org/swift-book/LanguageGuide/Extensions.html#//apple_ref/doc/uid/TP40014097-CH24-ID152](https://docs.swift.org/swift-book/LanguageGuide/Extensions.html#//apple_ref/doc/uid/TP40014097-CH24-ID152)&gt;[https://www.runoob.com/swift/swift-extensions.html](https://www.runoob.com/swift/swift-extensions.html)</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Swift中可以对类，结构体，协议，枚举进行拓展添加新的功能&lt;br&gt;考虑到本篇博文中的篇幅，关于枚举的拓展将在下一篇介绍&lt;code&gt;ps:&lt;/code&gt;基于Swift 5&lt;br&gt;Swift 中的扩展可以：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一、添加计算型属性和计算型静态属性&lt;/li&gt;
&lt;li&gt;二、定义实例方法和类型方法&lt;/li&gt;
&lt;li&gt;三、提供新的构造器&lt;/li&gt;
&lt;li&gt;四、定义下标&lt;/li&gt;
&lt;li&gt;五、定义和使用新的嵌套类型&lt;/li&gt;
&lt;li&gt;六、使一个已有类型符合某个协议
    
    </summary>
    
    
      <category term="Swift" scheme="http://yoursite.com/categories/Swift/"/>
    
    
      <category term="Swift" scheme="http://yoursite.com/tags/Swift/"/>
    
      <category term="Extension" scheme="http://yoursite.com/tags/Extension/"/>
    
  </entry>
  
  <entry>
    <title>Moya网络请求封装</title>
    <link href="http://yoursite.com/2020/04/30/2020/04/moyawrap/"/>
    <id>http://yoursite.com/2020/04/30/2020/04/moyawrap/</id>
    <published>2020-04-30T09:41:00.000Z</published>
    <updated>2020-04-30T09:42:13.905Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>最近项目中使用了Moya来做网络请求，于是对其简单封装一下以方便使用<br><a href="https://github.com/Moya/Moya" target="_blank" rel="noopener">Moya: https://github.com/Moya/Moya</a></p></blockquote><a id="more"></a><h3 id="自定义插件"><a href="#自定义插件" class="headerlink" title="自定义插件"></a>自定义插件</h3><pre><code>final class RequestLogPlugin: PluginType{    func willSend(_ request: RequestType, target: TargetType) {        Log(&quot;[URL]:\(request.request!.url!.absoluteString)&quot;)        if(request.request?.httpBody != nil){            let JSONString = NSString(data:(request.request?.httpBody!)!,encoding: String.Encoding.utf8.rawValue)            Log(&quot;[Param:]---------------------------------[&quot;)            Log(JSONString!)            Log(&quot;[Param:]---------------------------------]&quot;)        }    }}</code></pre><p>这里主要是添加了两个打印信息，一个请求的接口地址，一个是请求时的参数，方便在开发过程中调试。</p><h3 id="请求类"><a href="#请求类" class="headerlink" title="请求类"></a>请求类</h3><pre><code>import Moyaimport SwiftyJSONlet MAProvider = MoyaProvider&lt;MultiTarget&gt;( plugins: [RequestLogPlugin()])struct AHNetwork {    static func request(_ target:MultiTarget,success successCallback: @escaping (String) -&gt; Void,failure failureCallback: @escaping (MoyaError) -&gt; Void){        MAProvider.request(target) { (result) in            switch result {            case let .success(response):                let jsonData = response.data                let jsonString = String.init(data: jsonData, encoding: .utf8)                Log(&quot;[Reponse:]---------------------------------[&quot;)                Log(jsonString!)                Log(&quot;[Reponse:]---------------------------------]&quot;)                successCallback(jsonString!)            case let .failure(error):                Log(&quot;[Error:]\(String(describing: error.errorDescription))&quot;)                failureCallback(error)            }        }    }}</code></pre><p>1，定义一个<code>Provider</code>使用我们刚定义的<code>plugin</code><br>2，将请求方法都封装在AHNetwork中的<code>request</code>方法中，此方法需传入<code>target</code>，一个<code>success</code>的逃逸闭包和<code>failure</code>的逃逸闭包。<br>2，这里的<code>Log</code>函数为一个全局的打印函数，在本文最后贴出。<br>3，在这个函数内可以根据实际的业务需求添加一些需要统一处理的逻辑，比如<code>token</code>过期，错误处理之类的逻辑。</p><h3 id="API"><a href="#API" class="headerlink" title="API"></a>API</h3><pre><code>import Moyapublic enum AHVideoAPi {    case fetchVideoCategory    case fetchVideoCategoryDetail(_ id:Int)}extension AHVideoAPi : TargetType{    public var baseURL: URL {        return URL(string: &quot;https://api.apiopen.top&quot;)!    }    public var path: String {        switch self {        case .fetchVideoCategory:            return &quot;/videoCategory&quot;        case .fetchVideoCategoryDetail:            return &quot;/videoCategoryDetails&quot;        }    }    public var method: Moya.Method {        switch self {        case .fetchVideoCategory,.fetchVideoCategoryDetail:            return .post        }    }    public var sampleData: Data {        return &quot;{}&quot;.data(using: String.Encoding.utf8)!    }    public var task: Task {        switch self {        case .fetchVideoCategory:            return .requestPlain        case .fetchVideoCategoryDetail(let id):            let params: [String: Any] = [&quot;id&quot;:id]            return .requestParameters(parameters: params,encoding: URLEncoding.default)        }    }    public var headers: [String : String]? {        return nil    }</code></pre><p>Api类就是Moya的常规使用，这里就不多做解释了</p><h3 id="请求案例"><a href="#请求案例" class="headerlink" title="请求案例"></a>请求案例</h3><pre><code>AHNetwork.request(MultiTarget(AHVideoAPi.fetchVideoCategory), success: { (_) in    /// do something success}) { (_) in    /// do something error}</code></pre><h4 id="Log函数"><a href="#Log函数" class="headerlink" title="Log函数"></a>Log函数</h4><pre><code>func Log&lt;T&gt;(_ message:T,file:String = #file,funcName:String = #function,lineNum:Int = #line){    #if DEBUG    let file = (file as NSString).lastPathComponent;    print(&quot;\(file):(\(lineNum))--\(message)&quot;);    #endif  }</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;最近项目中使用了Moya来做网络请求，于是对其简单封装一下以方便使用&lt;br&gt;&lt;a href=&quot;https://github.com/Moya/Moya&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Moya: https://github.com/Moya/Moya&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
    
      <category term="Moya" scheme="http://yoursite.com/tags/Moya/"/>
    
  </entry>
  
  <entry>
    <title>序</title>
    <link href="http://yoursite.com/2020/04/25/2020/04/preface/"/>
    <id>http://yoursite.com/2020/04/25/2020/04/preface/</id>
    <published>2020-04-25T02:54:00.000Z</published>
    <updated>2020-04-25T04:32:07.431Z</updated>
    
    <content type="html"><![CDATA[<p><em>黄色的树林里分出两条路</em><br><em>可惜我不能同时涉足</em><br><em>我在那路口久久伫立</em><br><em>我向着一条路极目望去</em><br><em>直到它消失在丛林深处</em><br><em>但我却选了另外一条路</em><br><em>因此走出了这迥异的旅途</em></p><div style="text-align: right">摘自《未选择的路》</div><a id="more"></a><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>&#8194;&#8194;前面那首诗透露出的浪漫主义是令我非常神往的，所以放在了本站第一篇博客的顶部。笔者至今从事iOS开发已经三年了，三年了，开发水平依旧是平平无奇。记得刚毕业那会我给自己设定了两个目标，一个就是三年之内一定要独立开发一款自己的APP，另一个就是一个月至少更新四篇博客。如今博客压根没写几篇，APP尚未有任何雏形。笔者今天将穿上盔甲，拿起宝剑，踏上战马，再次出发。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;em&gt;黄色的树林里分出两条路&lt;/em&gt;&lt;br&gt;&lt;em&gt;可惜我不能同时涉足&lt;/em&gt;&lt;br&gt;&lt;em&gt;我在那路口久久伫立&lt;/em&gt;&lt;br&gt;&lt;em&gt;我向着一条路极目望去&lt;/em&gt;&lt;br&gt;&lt;em&gt;直到它消失在丛林深处&lt;/em&gt;&lt;br&gt;&lt;em&gt;但我却选了另外一条路&lt;/em&gt;&lt;br&gt;&lt;em&gt;因此走出了这迥异的旅途&lt;/em&gt;&lt;/p&gt;
&lt;div style=&quot;text-align: right&quot;&gt;摘自《未选择的路》&lt;/div&gt;
    
    </summary>
    
    
    
      <category term="序" scheme="http://yoursite.com/tags/%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://yoursite.com/2020/04/21/hello-world/"/>
    <id>http://yoursite.com/2020/04/21/hello-world/</id>
    <published>2020-04-21T13:00:24.786Z</published>
    <updated>2020-04-21T13:00:24.786Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre><code class="bash">$ hexo new &quot;My New Post&quot;</code></pre><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre><code class="bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre><code class="bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre><code class="bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
    
    
  </entry>
  
</feed>
